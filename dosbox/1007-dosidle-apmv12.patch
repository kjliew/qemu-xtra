diff -ru ../dosbox-code-0/src/cpu/callback.cpp ./src/cpu/callback.cpp
--- ../dosbox-code-0/src/cpu/callback.cpp
+++ ./src/cpu/callback.cpp
@@ -379,7 +379,8 @@
 			physAddress+=4;
 		}
 		phys_writeb(physAddress+0x01,(Bit8u)0xCF);		//An IRET Instruction
-		for (Bitu i=0;i<=0x0b;i++) phys_writeb(physAddress+0x02+i,0x90);
+		for (Bitu i=0;i<=0x0a;i++) phys_writeb(physAddress+0x02+i,0x90);
+		phys_writeb(physAddress+0x0d,(Bit8u)0xF4);	//HLT
 		phys_writew(physAddress+0x0e,(Bit16u)0xedeb);	//jmp callback
 		return (use_cb?0x10:0x0c);
 	case CB_INT29:	// fast console output
@@ -635,7 +636,8 @@
 	call_idle=CALLBACK_Allocate();
 	CallBack_Handlers[call_idle]=stop_handler;
 	CALLBACK_SetDescription(call_idle,"idle");
-	for (i=0;i<=11;i++) phys_writeb(CALLBACK_PhysPointer(call_idle)+i,0x90);
+	for (i=0;i<=9;i++) phys_writeb(CALLBACK_PhysPointer(call_idle)+i,0x90);
+	phys_writew(CALLBACK_PhysPointer(call_idle)+10,0xF4FB);
 	phys_writeb(CALLBACK_PhysPointer(call_idle)+12,0xFE);
 	phys_writeb(CALLBACK_PhysPointer(call_idle)+13,0x38);
 	phys_writew(CALLBACK_PhysPointer(call_idle)+14,(Bit16u)call_idle);
diff -ru ../dosbox-code-0/src/cpu/core_dyn_x86/string.h ./src/cpu/core_dyn_x86/string.h
--- ../dosbox-code-0/src/cpu/core_dyn_x86/string.h
+++ ./src/cpu/core_dyn_x86/string.h
@@ -16,7 +16,7 @@
  *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  */
 
-enum STRING_OP {
+enum STRING_OP_DYN_X86 {
 	STR_OUTSB=0,STR_OUTSW,STR_OUTSD,
 	STR_INSB=4,STR_INSW,STR_INSD,
 	STR_MOVSB=8,STR_MOVSW,STR_MOVSD,
@@ -26,7 +26,7 @@
 	STR_CMPSB=24,STR_CMPSW,STR_CMPSD
 };
 
-static void dyn_string(STRING_OP op) {
+static void dyn_string(STRING_OP_DYN_X86 op) {
 	DynReg * si_base=decode.segprefix ? decode.segprefix : DREG(DS);
 	DynReg * di_base=DREG(ES);
 	DynReg * tmp_reg;bool usesi;bool usedi;
diff -ru ../dosbox-code-0/src/cpu/core_normal/string.h ./src/cpu/core_normal/string.h
--- ../dosbox-code-0/src/cpu/core_normal/string.h
+++ ./src/cpu/core_normal/string.h
@@ -16,7 +16,7 @@
  *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  */
 
-enum STRING_OP {
+enum STRING_OP_NORMAL {
 	R_OUTSB,R_OUTSW,R_OUTSD,
 	R_INSB,R_INSW,R_INSD,
 	R_MOVSB,R_MOVSW,R_MOVSD,
@@ -28,7 +28,7 @@
 
 #define LoadD(_BLAH) _BLAH
 
-static void DoString(STRING_OP type) {
+static void DoString(STRING_OP_NORMAL type) {
 	PhysPt  si_base,di_base;
 	Bitu	si_index,di_index;
 	Bitu	add_mask;
diff -ru ../dosbox-code-0/src/ints/bios_keyboard.cpp ./src/ints/bios_keyboard.cpp
--- ../dosbox-code-0/src/ints/bios_keyboard.cpp
+++ ./src/ints/bios_keyboard.cpp
@@ -527,9 +527,11 @@
 		// enable interrupt-flag after IRET of this int16
 		CALLBACK_SIF(true);
 		for (;;) {
+                        static Bit32u elapsed;
 			if (check_key(temp)) { //  check_key changes ZF and CF as required
 				if (!IsEnhancedKey(temp)) {
 					/* normal key, return translated key in ax */
+                                        elapsed = SDL_GetTicks();
 					break;
 				} else {
 					/* remove enhanced key from buffer and ignore it */
@@ -537,21 +539,34 @@
 				}
 			} else {
 				/* no key available, return key at buffer head anyway */
+                                if ((SDL_GetTicks() - elapsed) > 20) {
+                                    elapsed = 0;
+                                    CALLBACK_Idle();
+                                }
 				break;
 			}
-//			CALLBACK_Idle();
 		}
 		reg_ax=temp;
 		break;
 	case 0x11: /* CHECK FOR KEYSTROKE (enhanced keyboards only) */
 		// enable interrupt-flag after IRET of this int16
 		CALLBACK_SIF(true);
-		if (check_key(temp)) { // check_key changes ZF and CF as required
-			if (((temp&0xff)==0xf0) && (temp>>8)) {
-				/* special enhanced key, clear low part before returning key */
-				temp&=0xff00;
-			}
-		}
+                do {
+                    static Bit32u elapsed;
+                    if (check_key(temp)) { // check_key changes ZF and CF as required
+                            elapsed = SDL_GetTicks();
+                            if (((temp&0xff)==0xf0) && (temp>>8)) {
+                                    /* special enhanced key, clear low part before returning key */
+                                    temp&=0xff00;
+                            }
+                    }
+                    else {
+                        if ((SDL_GetTicks() - elapsed) > 20) {
+                            elapsed = 0;
+                            CALLBACK_Idle();
+                        }
+                    }
+                } while(0);
 		reg_ax=temp;
 		break;
 	case 0x02:	/* GET SHIFT FLAGS */
diff -ru ../dosbox-code-0/src/cpu/callback.cpp ./src/cpu/callback.cpp
--- ../dosbox-code-0/src/cpu/callback.cpp
+++ ./src/cpu/callback.cpp
@@ -34,6 +34,8 @@
 char* CallBack_Description[CB_MAX];
 
 static Bitu call_stop,call_idle,call_default;
+extern Bitu handle_apm(void);
+Bitu entry_apm32;
 Bitu call_priv_io;
 
 static Bitu illegal_handler(void) {
@@ -642,6 +644,23 @@
 	phys_writeb(CALLBACK_PhysPointer(call_idle)+13,0x38);
 	phys_writew(CALLBACK_PhysPointer(call_idle)+14,(Bit16u)call_idle);
 
+        /* Setup APM 32-bit entry */
+        entry_apm32=CALLBACK_Allocate();
+        CallBack_Handlers[entry_apm32]=handle_apm;
+        CALLBACK_SetDescription(entry_apm32,"apm32");
+        phys_writeb(CALLBACK_PhysPointer(entry_apm32)+0x0,0x9c);   // pushf
+        phys_writew(CALLBACK_PhysPointer(entry_apm32)+0x1,0xa80f); // push gs
+        phys_writeb(CALLBACK_PhysPointer(entry_apm32)+0x3,0x0e);   // push cs
+        phys_writed(CALLBACK_PhysPointer(entry_apm32)+0x4,0x10240483); // addl [esp], +0x10
+        phys_writew(CALLBACK_PhysPointer(entry_apm32)+0x8,0xa90f); // pop gs
+        phys_writew(CALLBACK_PhysPointer(entry_apm32)+0xa,0xfcfa); // cli cld
+        phys_writeb(CALLBACK_PhysPointer(entry_apm32)+0xc,0xFE);
+        phys_writeb(CALLBACK_PhysPointer(entry_apm32)+0xd,0x38);
+        phys_writew(CALLBACK_PhysPointer(entry_apm32)+0xe,(Bit16u)entry_apm32);
+        phys_writew(CALLBACK_PhysPointer(entry_apm32)+0x10,0xf4fb); // sti hlt
+        phys_writew(CALLBACK_PhysPointer(entry_apm32)+0x12,0xa90f); // pop gs
+        phys_writew(CALLBACK_PhysPointer(entry_apm32)+0x14,0xcb9d); // popf retf
+
 	/* Default handlers for unhandled interrupts that have to be non-null */
 	call_default=CALLBACK_Allocate();
 	CALLBACK_Setup(call_default,&default_handler,CB_IRET,"default");
diff -ru ../dosbox-code-0/src/ints/Makefile.am ./src/ints/Makefile.am
--- ../dosbox-code-0/src/ints/Makefile.am
+++ ./src/ints/Makefile.am
@@ -4,4 +4,4 @@
 libints_a_SOURCES = mouse.cpp xms.cpp xms.h ems.cpp \
                     int10.cpp int10.h int10_char.cpp int10_memory.cpp int10_misc.cpp int10_modes.cpp \
                     int10_vesa.cpp int10_pal.cpp int10_put_pixel.cpp int10_video_state.cpp int10_vptable.cpp \
-                    bios.cpp bios_disk.cpp bios_keyboard.cpp 
+                    apm.cpp bios.cpp bios_disk.cpp bios_keyboard.cpp 
diff -ru ../dosbox-code-0/src/ints/bios.cpp ./src/ints/bios.cpp
--- ../dosbox-code-0/src/ints/bios.cpp
+++ ./src/ints/bios.cpp
@@ -782,6 +782,13 @@
 		/* Carry should be set but let's just set it just in case */
 		CALLBACK_SCF(true);
 		break;
+        case 0x53:      /* BIOS - APM calls */
+                extern void handle_1553(void);
+                handle_1553();
+                /* Not useful for real-mode
+                 * if (reg_ax == 0x5305)
+                    CALLBACK_Idle(); */
+                break;
 	case 0x83:	/* BIOS - SET EVENT WAIT INTERVAL */
 		{
 			if(reg_al == 0x01) { /* Cancel it */
